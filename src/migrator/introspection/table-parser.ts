/**
 * @fileoverview Table definition parser for SurrealDB schema introspection.
 * @module migrator/introspection/table-parser
 */

import { debugLog } from '../../utils/debug-logger';
import { parseEventDefinition } from './event-parser';
import { parseFieldDefinition } from './field-parser';
import { parseIndexDefinition } from './index-parser';

/**
 * Parses the result of a SurrealDB INFO FOR TABLE command into a structured format.
 *
 * @param tableName - The name of the table being parsed
 * @param infoResult - The raw result object from INFO FOR TABLE command
 * @returns Structured table schema object ready for comparison
 */
export function parseTableInfo(tableName: string, infoResultRaw: unknown): Record<string, unknown> {
  const infoResult = infoResultRaw as Record<string, unknown>;
  debugLog(`Parsing info result for ${tableName}:`, infoResult);

  const fields: Record<string, unknown>[] = [];
  const indexes: Record<string, unknown>[] = [];
  const events: Record<string, unknown>[] = [];

  // Parse fields from the info result
  if (infoResult.fields) {
    for (const [fieldName, fieldDef] of Object.entries(
      infoResult.fields as Record<string, unknown>,
    )) {
      // Skip array wildcard fields (e.g., followers[*]) - these are auto-generated by SurrealDB
      if (fieldName.includes('[*]')) {
        continue;
      }

      const parsedField = parseFieldDefinition(fieldName, fieldDef as string);

      debugLog(`Parsed field ${fieldName} in table ${tableName}:`, parsedField);
      fields.push(parsedField);
    }
  }

  // Parse indexes from the info result
  if (infoResult.indexes) {
    for (const [indexName, indexDef] of Object.entries(
      infoResult.indexes as Record<string, unknown>,
    )) {
      const parsedIndex = parseIndexDefinition(indexName, indexDef as string);
      debugLog(`Parsed index ${indexName} in table ${tableName}:`, parsedIndex);
      indexes.push(parsedIndex);
    }
  }

  // Parse events from the info result
  if (infoResult.events) {
    for (const [eventName, eventDef] of Object.entries(
      infoResult.events as Record<string, unknown>,
    )) {
      const parsedEvent = parseEventDefinition(eventName, eventDef as string);
      debugLog(`Parsed event ${eventName} in table ${tableName}:`, parsedEvent);
      events.push(parsedEvent);
    }
  }

  // Extract table-level properties
  const tableDefStr = (infoResult.tb || '') as string;
  const schemafull = tableDefStr.includes('SCHEMAFULL') || !tableDefStr.includes('SCHEMALESS');
  const drop = tableDefStr.includes('DROP');

  // Check for table type (NORMAL, RELATION, ANY)
  let type = 'NORMAL';
  if (tableDefStr.includes('TYPE RELATION')) type = 'RELATION';
  else if (tableDefStr.includes('TYPE ANY')) type = 'ANY';

  // Check for changefeed
  const changefeedMatch = tableDefStr.match(/CHANGEFEED\s+(\d+[smhdwy])/i);
  const changefeedDuration = changefeedMatch ? changefeedMatch[1] : null;
  const changefeedIncludeOriginal = tableDefStr.includes('INCLUDE ORIGINAL');

  // Build the table info object
  const tableInfo = {
    name: tableName,
    schemafull,
    drop,
    type,
    changefeedDuration,
    changefeedIncludeOriginal,
    fields,
    indexes,
    events,
    isRelation: false,
    relationInfo: null as { from: string | null; to: string | null } | null,
  };

  // Check if this is a relation table and extract relation info
  tableInfo.isRelation = isRelationTable(tableName, tableInfo);
  if (tableInfo.isRelation) {
    tableInfo.relationInfo = extractRelationInfo(tableInfo);
  }

  return tableInfo;
}

/**
 * Determines if a table is a relation table based on its schema.
 *
 * A table is considered a relation if:
 * 1. It has TYPE RELATION in its definition, OR
 * 2. It has both 'in' and 'out' fields with record types
 *
 * @param tableName - The name of the table
 * @param tableInfo - The parsed table info
 * @returns True if the table is a relation
 */
export function isRelationTable(_tableName: string, tableInfo: Record<string, unknown>): boolean {
  // Check if explicitly marked as RELATION type
  if (tableInfo.type === 'RELATION') {
    return true;
  }

  // Check for presence of 'in' and 'out' fields with record types
  const fields = tableInfo.fields as Array<Record<string, unknown>>;
  if (!fields || fields.length === 0) {
    return false;
  }

  const hasInField = fields.some((f) => f.name === 'in' && String(f.type).startsWith('record'));
  const hasOutField = fields.some((f) => f.name === 'out' && String(f.type).startsWith('record'));

  return hasInField && hasOutField;
}

/**
 * Extracts relation from/to information from a table's in/out fields.
 *
 * @param tableInfo - The parsed table info
 * @returns Object with from and to table names
 */
export function extractRelationInfo(tableInfo: Record<string, unknown>): {
  from: string | null;
  to: string | null;
} {
  const fields = tableInfo.fields as Array<Record<string, unknown>>;
  if (!fields) {
    return { from: null, to: null };
  }

  let from: string | null = null;
  let to: string | null = null;

  const inField = fields.find((f) => f.name === 'in');
  const outField = fields.find((f) => f.name === 'out');

  if (inField) {
    const typeStr = String(inField.type);
    // Extract table name from record<tablename> or record<table1 | table2>
    const match = typeStr.match(/record<([^>]+)>/);
    if (match) {
      from = match[1].split('|')[0].trim();
    }
  }

  if (outField) {
    const typeStr = String(outField.type);
    const match = typeStr.match(/record<([^>]+)>/);
    if (match) {
      to = match[1].split('|')[0].trim();
    }
  }

  return { from, to };
}
